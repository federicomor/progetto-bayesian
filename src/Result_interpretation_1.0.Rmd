---
title: "R Notebook"
output: html_document
---

```{r,warning = FALSE}
source("include.R") 
source("plot functions/plotter.R")

source("include_clusters_functions.R")
library(patchwork)
```


```{r}
# need these for the plotting functions
sites = data.frame(
	longitude = unique(df_weekly$Longitude), 
	latitude = unique(df_weekly$Latitude))

std_sites = data.frame(
	longitude = unique(df_wsc$Longitude), 
	latitude = unique(df_wsc$Latitude))

stations = unique(df_wsc$IDStations)
y=data.frame()

for(st in stations){
  y_we_pm10=cbind(as.data.frame(st),t(df_wsc[which(df_wsc$IDStations==st),"AQ_pm10"]))
  y=rbind(y,y_we_pm10)
}

rownames(y) = NULL
colnames(y)<- c("id",paste0("w", 1:53))


load("salso_out_lists.Rdata")
# usage: clusters are given by
#    salso_out_lists[["model name"]][week]
# where model name in
mods = c("DRPM","sPPM","Gaussian PPMx","Curve PPMx")

# and this for mode clusters
load("salso_out_mode_cl.Rdata")
salso_out_mode_cl
```


```{r}
# if around we need df_cluster_cut for the graph plot, here is how it is defined
# df_cluster_cut = data.frame(
# 	Longitude = sites$longitude,
# 	Latitude = sites$latitude,
# 	clusters = CLUSTERS, # change with something from salso_out_lists
# 	Time = WEEK # change with the current week
# )
build_df_cluster_cut = function(time,clusters){
	df_cluster_cut = data.frame(
		Longitude = sites$longitude,
		Latitude = sites$latitude,
		clusters = salso_out_mode_cl$DRPM, # change with something from salso_out_lists
		Time = time # change with the current week
	)
	return(df_cluster_cut)
}
```

```{r}
interest_variables <- c("EM_nh3_livestock_mm",
"LA_hvi",
"LA_lvi",
"Altitude",
"EM_nox_sum",
"WE_wind_speed_100m_max",
"WE_tot_precipitation"
)
```


```{r}
other_vars <- c("IDStations","Latitude","Longitude","week")
df_interst <- df_weekly[,c(interest_variables,"AQ_pm10",other_vars)]
head(df_interst)
df_interst$logAltitude = log(df_interst$Altitude)
interest_variables <- c(interest_variables,"logAltitude")
# small modification to not change functions
colnames(df_interst)[which(colnames(df_interst)=="week") ] = "Time"
```
#  Map expanding radius

```{r,warning=FALSE}
initial_date = "2018-01-01"
final_date = "2019-01-01"
every = "year"

# if you change the file_name from None it will create a mp4 video
file_name = "None"

chosen_var_name = "AQ_pm10" 

circles_plot <- circlesPlot(initial_date,final_date,every,file_name,chosen_var_name)
```




# XY PLOT function
```{r}
cols = colora(6,970,show=F)
xyPlot_weekly <- function(file_name,var1_name,var2_name,size_name){

	data_from_to = df_interst
	len_time = 12 # number of weeks
	
	
	var1 = data_from_to[,var1_name][[1]]
	var2 = data_from_to[,var2_name][[1]]
	if(class(size_name)!="numeric"){
		size = data_from_to[,size_name][[1]]
	}else{
		size = size_name
	}
	colors_factor = factor(data_from_to$color_clusters)
	
	if(class(size_name)!="numeric"){
		p <- ggplot(
			data_from_to, 
			aes(x = var1, y = var2, size = size, colour = colors_factor)) +
			geom_point(alpha = 1) +
			#scale_color_manual(values = cols) +
			scale_color_viridis_d() +
			scale_size(range = c(2, 12)) +
			labs(x = var1, y = var2)+
			guides(size = guide_legend(title = size_name), color = "none")+
			theme_bw()
	}else{
		p <- ggplot(
			data_from_to, 
			aes(x = var1, y = var2, size = size, colour = colors_factor)) +
			geom_point(alpha = 1,size=size,show.legend = FALSE) +
			scale_color_viridis_d() +
			scale_size(range = c(2, 12)) +
			labs(x = var1_name, y =var2_name)+
			theme_bw()
	}
	
	return(animator(file_name,p,data_from_to,len_time,1080,1080,TRUE))
	
}
```


# xy color+size in time
```{r,warning=FALSE}
var2_name = "AQ_pm10" # y
size_name = 3
#size_name = "Altitude"
#file_name= "None"
for(j in 1:4){
	colors_clusters = salso_out_mode_cl[[j]]
	ii = 1
	
	for(st in unique(df_interst$IDStations)){
		df_interst$color_clusters[df_interst$IDStations==st] = colors_clusters[ii]
		ii = ii + 1	
	}
	

	for(vars in interest_variables){
		file_name= paste0(names(salso_out_mode_cl)[j],"xy_plot_pm10-",vars)
		# you can change size to refer to a particular variable
	
		
		xyplot <- xyPlot_weekly(file_name,vars,var2_name,size_name)
		xyplot
	}
}
```


## plots separeted
```{r}
df_cluster = data.frame(Longitude=c(),Latitude=c(),values=c(),clusters=c(),Time=c())
mode_clusters_vect = rep(0,105)


sites = data.frame(
	longitude = unique(df_weekly$Longitude), 
	latitude = unique(df_weekly$Latitude))

df_temp = data.frame(
	Longitude = sites$longitude,
	Latitude = sites$latitude,
	clusters = colors_clusters
)


# clusters log
clusters_now = df_temp$clusters
# n_clusters = max(clusters_now)
n_clusters = unique(clusters_now)

stations = unique(df_wsc$IDStations)
y=data.frame()

for(st in stations){
  y_we_pm10=cbind(as.data.frame(st),t(df_wsc[which(df_wsc$IDStations==st),"AQ_pm10"]))
  y=rbind(y,y_we_pm10)
}

# time = 2
# cols = color_correct_clusters(df_temp,idea=2,verbose=0,nint=13)
p = get_graph_plot(df_temp,titolo="Mode Clusters")
p
map = gridMap("2016-01-01","2016-01-01","","None","Altitude")
map
```
# media settimanale
```{r}
# Carica la libreria dplyr
library(dplyr)
data_agc_lomb_weekly = data_agc_lomb[,c("EM_nh3_livestock_mm",
										"LA_hvi"   ,              
										"LA_lvi"    ,            
										"Altitude" ,             
										"EM_nox_sum"         ,    
										"WE_wind_speed_100m_max", 
										"WE_tot_precipitation" 
										,"Latitude","Longitude","Time")]

# Converti la variabile Time in formato Date
data_agc_lomb_weekly$Time <- as.Date(data_agc_lomb_weekly$Time)


data_agc_lomb_weekly_2018 = data_agc_lomb_weekly[lubridate::year(data_agc_lomb_weekly$Time)=="2018",]
# Aggiungi una nuova colonna che rappresenta la settimana dell'anno
data_agc_lomb_weekly_2018$Week <- lubridate::week(data_agc_lomb_weekly_2018$Time)

data_agc_lomb_weekly_2018$LA_hvi = as.numeric(data_agc_lomb_weekly_2018$LA_hvi)
data_agc_lomb_weekly_2018$LA_lvi = as.numeric(data_agc_lomb_weekly_2018$LA_lvi)
data_agc_lomb_weekly_2018$WE_tot_precipitation = as.numeric(data_agc_lomb_weekly_2018$WE_tot_precipitation)



# Calcola la media settimanale per tutte le variabili numeriche
data_agc_lomb_weekly_2018_mean <- data_agc_lomb_weekly_2018 %>%
  group_by(Latitude,Longitude,Week) %>%
  summarise_all(funs(mean(., na.rm = TRUE)))
```

# settings
```{r}
data_from_to = data_agc_lomb_weekly_2018_mean
len_time = 53

```


# plot composition with changing graphs

```{r}
united_plot <- function(time_step){
	
	data_from_to = data_agc_lomb_weekly_2018_mean[data_agc_lomb_weekly_2018_mean$Week==time_step,]

	chosen_variable = as.numeric(data_from_to[[chosen_variable_name]])
	
	edges_list = assemble_edges_list(df_cluster_cut$clusters)
	p  <-  ggplot() +

	geom_tile(data = data_from_to, aes(x = Longitude, y = Latitude, fill = chosen_variable), 
			  colour = "grey50",alpha = 0.9) +
	
	scale_fill_gradient(low = color_low, high = color_high,na.value = "gray",
						breaks = extrema(chosen_variable)
					#	,trans = "log",  # Apply a logarithmic transformation (adjust as needed)
					#	oob = scales::squish  # Squish out-of-bounds values to the nearest limit
						) +
	labs(title = chosen_variable_name, fill = chosen_variable_name)+
		
		
	geom_point(data = df_cluster_cut, aes(x = Longitude, y = Latitude,
										  # color = cols[factor(clusters)]), size = 2)+
										  color = cols[clusters]), size = 2)+
	labs(title = titolo)+
 theme(legend.position = "right",  # Imposta la posizione della legenda in basso
        legend.justification = "bottom")  # Allinea la legenda sulla sinistra
	
	q = p

	actual_clusters = c()
	for(cl in 1:len(edges_list)){
		edges_to_plot = edges_list[[cl]]
		if(!is.null(edges_to_plot)){
			actual_clusters = c(actual_clusters,cl)
			if(verbose==1){
				cat("procesing cluster",cl,"\n")
				print(actual_clusters)
			}
			q = q + 
				geom_segment(aes(x = x, y = y, xend = xend, yend = yend,
									 color = cols[as.numeric(cluster)]),
								  linewidth=1.2, data = edges_to_plot, show.legend = TRUE)+
				

				guides(color = guide_legend(title = "Clusters"))
		}

	}
	qf = q +
		geom_sf(data = altre_regioni, fill = color_empty ,
					color = color_fill, linewidth = 0.3,alpha=0.01, show.legend = FALSE) +
		geom_sf(data = lombardia_2, fill = color_empty, color = "gold", 
				linewidth = 0.3,alpha=0.07, show.legend = FALSE) +
		
		coord_sf(xlim = range(sites$longitude) + padding, ylim = range(sites$latitude) + padding, 
				 expand = FALSE)+

		theme_bw()
	
	print(qf)

	
}
```


```{r}
library(magick)
library(animation)
library(gifski)
library(av)
cols=color_correct_clusters(df_cluster_cut,idea = 2,verbose = 0,nint= 15)
color_low =  "white"
color_high = "black" 
cols=cols_default
verbose = 0

interest_variables_animated_grid = c("EM_nh3_livestock_mm",
"LA_hvi",
"LA_lvi",
"EM_nox_sum",
"WE_wind_speed_100m_max",
"WE_tot_precipitation"
)

build_df_cluster_cut = function(time,clusters){
df_cluster_cut = data.frame(
	Longitude = sites$longitude,
	Latitude = sites$latitude,
	clusters = clusters, # change with something from salso_out_lists
	Time = i # change with the current week
)
return(df_cluster_cut)
}

```

# build gif and images

```{r}
frammeratte = 2
for(mod in 1:4){
	for( var in interest_variables_animated_grid){
		chosen_variable_name = var
		titolo = chosen_variable_name
		name_rdata = paste0("./plot functions/gifs/",
								  names(salso_out_mode_cl)[mod],"-",chosen_variable_name)
								 # Crea la nuova cartella
		dir.create(name_rdata)
		
	#	LISTA_PLOT = readRDS(paste0(name_rdata,".Rdata"))
		for (time in 1:53){
			#CUR_PLOT = LISTA_PLOT[[time]] # or similar, dipende come hai salvato le varie cose
			
			df_cluster_cut = build_df_cluster_cut(time,salso_out_mode_cl[[mod]])
				current_plot = united_plot(time)
			
			
			cur_num = sprintf("%02d", time) # tempo con due cifre necessario per le gif su latex
			
			
			ggsave(file=paste0(name_rdata,"/",names(salso_out_mode_cl)[mod],"-",chosen_variable_name,"-",cur_num,".png"),
			   plot = current_plot,
			   units="px", width=2000, height=1200) # maybe try to change them

		}
		
		#### create mp4 ####
		imgs <- list.files(path = name_rdata, pattern = ".png", full.names = TRUE)
		img_list <- lapply(imgs, image_read)
		## join the images together
		img_joined <- image_join(img_list)
		## animate at 1 frames per second. 1 to freely control the fps/framerate later
		img_animated <- image_animate(img_joined, fps = 1)
		image_write_video(image = img_animated, path = paste0(name_rdata,".mp4"),framerate=frammeratte)

	}
	
}
```



# animate
```{r}
file_name = paste0("2grid+graph-",chosen_variable_name)
animated_plot = animator(file_name,qf,data_from_to,len_time,1920,1080)
```

































## wind-doesn't work
```{r}
color_background_map = "forestgreen"


data_from_to <- data_from_to[order(data_from_to$Latitude), ]
data_from_to <- data_from_to[order(data_from_to$Longitude), ]

wind_arrows <- data.frame(
	longitude = data_from_to$Longitude,
	latitude = data_from_to$Latitude,
	direction = cardinal_to_degree(data_from_to$WE_mode_wind_direction_10m),
	intensity = as.numeric(data_from_to$WE_wind_speed_10m_mean)
)

# Calcola le coordinate di fine delle frecce in base alla direzione 
# l'intensitÃ  verra colorata invece di cambiare in lunghezza
wind_arrows$end_longitude =( wind_arrows$longitude + sin(wind_arrows$direction)/10)
wind_arrows$end_latitude = ( wind_arrows$latitude + cos(wind_arrows$direction)/10)
# put a 0 in the NA
wind_arrows[is.na(wind_arrows)] <- 0

time_vect = c()
for(i in 1:1053) {
	time_vect <- c(time_vect,seq(1,len_time))
}
wind_arrows$Time = time_vect


mappa_wind <- ggplot() +
	
	geom_sf(data = shp_map, fill = color_background_map , color = "black", linewidth = 0.5,alpha=0.6)+
	coord_sf(xlim = range(na.omit(wind_arrows$longitude))+padding,
			 ylim = range(na.omit(wind_arrows$latitude))+padding, expand = FALSE)+
	
	geom_segment(data = wind_arrows,
				 aes(x = longitude, y = latitude, xend = end_longitude, yend = end_latitude,
				 	color = intensity),
				 arrow = arrow(type = "closed", length = unit(0.08, "inches"), ends = "last"),
				 lineend = "round", size = 0.3,alpha=0.9 )+

	labs(title="Wind map")

p = mappa_wind
```

